<!DOCTYPE html>
<html lang="en">
<head>
    <script src="../coi-serviceworker.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Image Processing - OpenCV.js Demos</title>
    <link rel="stylesheet" href="../css/theme.css">
</head>
<body>
    <div class="container">
        <!-- Breadcrumb Navigation -->
        <nav class="nav-breadcrumb">
            <a href="../index.html">Home</a>
            <span>/</span>
            <span class="current">Core Image Processing</span>
        </nav>

        <!-- Page Header -->
        <header class="page-header">
            <h1>Core Image Processing</h1>
            <p>Explore fundamental OpenCV operations including color conversion, filtering, edge detection, thresholding, morphological operations, and histogram analysis.</p>
        </header>

        <!-- Section 1: Color Conversion -->
        <section class="demo-section" id="color-section">
            <h3>Color Conversion</h3>
            <p class="text-secondary mb-md">Convert images between different color spaces and split into individual channels.</p>

            <div class="demo-controls" id="color-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="color-input"></canvas>
                    <span class="canvas-label">Original</span>
                </div>
                <div class="canvas-container">
                    <canvas id="color-output"></canvas>
                    <span class="canvas-label">Result</span>
                </div>
            </div>

            <div class="metrics" id="color-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="color-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Image Size</span>
                    <span class="metric-value" id="color-size">-</span>
                </div>
            </div>
        </section>

        <!-- Section 2: Blur & Smoothing -->
        <section class="demo-section" id="blur-section">
            <h3>Blur & Smoothing</h3>
            <p class="text-secondary mb-md">Apply various smoothing filters to reduce noise and detail in images.</p>

            <div class="demo-controls" id="blur-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="blur-input"></canvas>
                    <span class="canvas-label">Before</span>
                </div>
                <div class="canvas-container">
                    <canvas id="blur-output"></canvas>
                    <span class="canvas-label">After</span>
                </div>
            </div>

            <div class="metrics" id="blur-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="blur-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Kernel Size</span>
                    <span class="metric-value" id="blur-kernel-display">-</span>
                </div>
            </div>
        </section>

        <!-- Section 3: Edge Detection -->
        <section class="demo-section" id="edge-section">
            <h3>Edge Detection</h3>
            <p class="text-secondary mb-md">Detect edges using various algorithms including Canny, Sobel, Laplacian, and Scharr.</p>

            <div class="demo-controls" id="edge-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="edge-input"></canvas>
                    <span class="canvas-label">Original</span>
                </div>
                <div class="canvas-container">
                    <canvas id="edge-output"></canvas>
                    <span class="canvas-label">Edges</span>
                </div>
            </div>

            <div class="metrics" id="edge-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="edge-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Algorithm</span>
                    <span class="metric-value" id="edge-algo">-</span>
                </div>
            </div>
        </section>

        <!-- Section 4: Thresholding -->
        <section class="demo-section" id="threshold-section">
            <h3>Thresholding</h3>
            <p class="text-secondary mb-md">Convert images to binary using various thresholding techniques.</p>

            <div class="demo-controls" id="threshold-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="threshold-input"></canvas>
                    <span class="canvas-label">Original</span>
                </div>
                <div class="canvas-container">
                    <canvas id="threshold-output"></canvas>
                    <span class="canvas-label">Thresholded</span>
                </div>
            </div>

            <div class="metrics" id="threshold-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="threshold-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Threshold Value</span>
                    <span class="metric-value" id="threshold-val">-</span>
                </div>
            </div>
        </section>

        <!-- Section 5: Morphological Operations -->
        <section class="demo-section" id="morph-section">
            <h3>Morphological Operations</h3>
            <p class="text-secondary mb-md">Apply morphological transformations like dilation, erosion, opening, and closing.</p>

            <div class="demo-controls" id="morph-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="morph-input"></canvas>
                    <span class="canvas-label">Original</span>
                </div>
                <div class="canvas-container">
                    <canvas id="morph-output"></canvas>
                    <span class="canvas-label">Result</span>
                </div>
            </div>

            <div class="metrics" id="morph-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="morph-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Operation</span>
                    <span class="metric-value" id="morph-op">-</span>
                </div>
            </div>
        </section>

        <!-- Section 6: Histogram -->
        <section class="demo-section" id="histogram-section">
            <h3>Histogram Analysis</h3>
            <p class="text-secondary mb-md">Visualize image histograms and apply histogram equalization for contrast enhancement.</p>

            <div class="demo-controls" id="histogram-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="histogram-input"></canvas>
                    <span class="canvas-label">Image</span>
                </div>
                <div class="canvas-container">
                    <canvas id="histogram-chart" width="512" height="200"></canvas>
                    <span class="canvas-label">Histogram</span>
                </div>
            </div>

            <div class="demo-output mt-md">
                <div class="canvas-container">
                    <canvas id="histogram-output"></canvas>
                    <span class="canvas-label">Equalized</span>
                </div>
                <div class="canvas-container">
                    <canvas id="histogram-eq-chart" width="512" height="200"></canvas>
                    <span class="canvas-label">Equalized Histogram</span>
                </div>
            </div>

            <div class="metrics" id="histogram-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="histogram-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Mode</span>
                    <span class="metric-value" id="histogram-mode">-</span>
                </div>
            </div>
        </section>
    </div>

    <!-- Scripts -->
    <script src="../js/opencv-loader.js"></script>
    <script src="../js/utils.js"></script>
    <script src="../js/ui-components.js"></script>

    <script>
        // Store loaded images for each section
        const sectionData = {
            color: { mat: null },
            blur: { mat: null },
            edge: { mat: null },
            threshold: { mat: null },
            morph: { mat: null },
            histogram: { mat: null }
        };

        // Sample image URL
        const SAMPLE_IMAGE = '../images/lena.png';

        // Initialize the page
        async function init() {
            try {
                await UIComponents.initPage({
                    title: 'Core Image Processing',
                    buildType: 'full'
                });

                setupColorSection();
                setupBlurSection();
                setupEdgeSection();
                setupThresholdSection();
                setupMorphSection();
                setupHistogramSection();

            } catch (error) {
                console.error('Failed to initialize:', error);
                UIComponents.showToast({
                    message: 'Failed to load OpenCV.js: ' + error.message,
                    type: 'error',
                    duration: 5000
                });
            }
        }

        // Helper: Load image for a section (supports File, URL, or cv.Mat)
        async function loadImageForSection(section, source) {
            try {
                // Clean up previous mat
                if (sectionData[section].mat) {
                    sectionData[section].mat.delete();
                }

                let mat;
                let width, height;

                if (source && source.rows !== undefined && source.cols !== undefined && typeof source.clone === 'function') {
                    // Source is already a cv.Mat (from webcam capture)
                    mat = source.clone();
                    width = mat.cols;
                    height = mat.rows;
                } else {
                    // Source is a File or URL
                    const img = await Utils.loadImage(source);
                    mat = Utils.imageToMat(img);
                    width = img.width;
                    height = img.height;
                }

                sectionData[section].mat = mat;

                // Display on input canvas
                const inputCanvas = document.getElementById(`${section}-input`);
                inputCanvas.width = width;
                inputCanvas.height = height;
                cv.imshow(inputCanvas, sectionData[section].mat);

                // Resize output canvas
                const outputCanvas = document.getElementById(`${section}-output`);
                if (outputCanvas) {
                    outputCanvas.width = width;
                    outputCanvas.height = height;
                }

                return true;
            } catch (error) {
                UIComponents.showToast({
                    message: 'Failed to load image: ' + error.message,
                    type: 'error'
                });
                return false;
            }
        }

        // Helper: Download result
        function downloadResult(canvasId, filename) {
            Utils.downloadCanvas(canvasId, filename);
            UIComponents.showToast({
                message: 'Image downloaded',
                type: 'success'
            });
        }

        // =====================
        // Section 1: Color Conversion
        // =====================
        function setupColorSection() {
            const controls = document.getElementById('color-controls');

            // Input source selector (Upload + Webcam)
            const inputSource = UIComponents.createInputSourceSelector({
                id: 'color-input-source',
                onImageLoad: (source) => loadImageForSection('color', source),
                showCapture: true
            });
            controls.appendChild(inputSource);

            // Separator
            const separator = document.createElement('div');
            separator.style.width = '1px';
            separator.style.height = '30px';
            separator.style.background = 'var(--border-color)';
            controls.appendChild(separator);

            // Conversion buttons
            const conversions = [
                { text: 'Grayscale', action: 'gray' },
                { text: 'HSV', action: 'hsv' },
                { text: 'LAB', action: 'lab' },
                { text: 'RGB Channels', action: 'channels' }
            ];

            conversions.forEach(({ text, action }) => {
                const btn = UIComponents.createButton({
                    text,
                    className: 'btn btn-primary',
                    onClick: () => applyColorConversion(action)
                });
                controls.appendChild(btn);
            });

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('color-output', 'color-converted.png')
            });
            controls.appendChild(downloadBtn);
        }

        function applyColorConversion(action) {
            if (!sectionData.color.mat) {
                UIComponents.showToast({ message: 'Please load an image first', type: 'warning' });
                return;
            }

            const src = sectionData.color.mat;
            let dst = new cv.Mat();

            try {
                const start = performance.now();

                switch (action) {
                    case 'gray':
                        cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
                        break;
                    case 'hsv':
                        const rgb = new cv.Mat();
                        cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);
                        cv.cvtColor(rgb, dst, cv.COLOR_RGB2HSV);
                        rgb.delete();
                        break;
                    case 'lab':
                        const rgb2 = new cv.Mat();
                        cv.cvtColor(src, rgb2, cv.COLOR_RGBA2RGB);
                        cv.cvtColor(rgb2, dst, cv.COLOR_RGB2Lab);
                        rgb2.delete();
                        break;
                    case 'channels':
                        // Split into RGB channels and display side by side
                        const channels = new cv.MatVector();
                        cv.split(src, channels);

                        const width = src.cols;
                        const height = src.rows;
                        dst = new cv.Mat(height, width * 3, cv.CV_8UC1);

                        // Copy each channel to a region
                        const r = channels.get(0);
                        const g = channels.get(1);
                        const b = channels.get(2);

                        r.copyTo(dst.roi(new cv.Rect(0, 0, width, height)));
                        g.copyTo(dst.roi(new cv.Rect(width, 0, width, height)));
                        b.copyTo(dst.roi(new cv.Rect(width * 2, 0, width, height)));

                        // Clean up
                        for (let i = 0; i < channels.size(); i++) {
                            channels.get(i).delete();
                        }
                        channels.delete();
                        break;
                }

                const time = (performance.now() - start).toFixed(2);

                // Update output canvas size for channels view
                const outputCanvas = document.getElementById('color-output');
                outputCanvas.width = dst.cols;
                outputCanvas.height = dst.rows;

                cv.imshow('color-output', dst);

                // Update metrics
                UIComponents.updateMetric('color-time', `${time}ms`);
                UIComponents.updateMetric('color-size', `${src.cols}x${src.rows}`);

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
            }
        }

        // =====================
        // Section 2: Blur & Smoothing
        // =====================
        let blurKernelSize = 5;

        function setupBlurSection() {
            const controls = document.getElementById('blur-controls');

            // Input source selector (Upload + Webcam)
            const inputSource = UIComponents.createInputSourceSelector({
                id: 'blur-input-source',
                onImageLoad: (source) => loadImageForSection('blur', source),
                showCapture: true
            });
            controls.appendChild(inputSource);

            // Kernel size slider (odd values only: 3, 5, 7, ... 31)
            const slider = UIComponents.createRangeSlider({
                id: 'blur-kernel',
                label: 'Kernel Size',
                min: 3,
                max: 31,
                value: 5,
                step: 2,
                onChange: (val) => { blurKernelSize = val; }
            });
            controls.appendChild(slider);

            // Separator
            const separator = document.createElement('div');
            separator.style.width = '1px';
            separator.style.height = '30px';
            separator.style.background = 'var(--border-color)';
            controls.appendChild(separator);

            // Blur type buttons
            const blurTypes = [
                { text: 'Gaussian', action: 'gaussian' },
                { text: 'Median', action: 'median' },
                { text: 'Bilateral', action: 'bilateral' },
                { text: 'Box Blur', action: 'box' }
            ];

            blurTypes.forEach(({ text, action }) => {
                const btn = UIComponents.createButton({
                    text,
                    className: 'btn btn-primary',
                    onClick: () => applyBlur(action)
                });
                controls.appendChild(btn);
            });

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('blur-output', 'blurred.png')
            });
            controls.appendChild(downloadBtn);
        }

        function applyBlur(action) {
            if (!sectionData.blur.mat) {
                UIComponents.showToast({ message: 'Please load an image first', type: 'warning' });
                return;
            }

            const src = sectionData.blur.mat;
            let dst = new cv.Mat();

            try {
                const start = performance.now();
                const ksize = blurKernelSize;

                switch (action) {
                    case 'gaussian':
                        cv.GaussianBlur(src, dst, new cv.Size(ksize, ksize), 0);
                        break;
                    case 'median':
                        cv.medianBlur(src, dst, ksize);
                        break;
                    case 'bilateral':
                        const rgb = new cv.Mat();
                        cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);
                        const bilateralDst = new cv.Mat();
                        cv.bilateralFilter(rgb, bilateralDst, ksize, ksize * 2, ksize / 2);
                        cv.cvtColor(bilateralDst, dst, cv.COLOR_RGB2RGBA);
                        rgb.delete();
                        bilateralDst.delete();
                        break;
                    case 'box':
                        cv.blur(src, dst, new cv.Size(ksize, ksize));
                        break;
                }

                const time = (performance.now() - start).toFixed(2);

                cv.imshow('blur-output', dst);

                // Update metrics
                UIComponents.updateMetric('blur-time', `${time}ms`);
                UIComponents.updateMetric('blur-kernel-display', `${ksize}x${ksize}`);

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
            }
        }

        // =====================
        // Section 3: Edge Detection
        // =====================
        let edgeLowThreshold = 50;
        let edgeHighThreshold = 150;

        function setupEdgeSection() {
            const controls = document.getElementById('edge-controls');

            // Image upload
            const upload = UIComponents.createImageUpload({
                id: 'edge-upload',
                label: 'Upload Image',
                onChange: (file) => loadImageForSection('edge', file)
            });
            controls.appendChild(upload);

            // Sample image button
            const sampleBtn = UIComponents.createButton({
                text: 'Use Sample',
                className: 'btn btn-secondary',
                onClick: () => loadImageForSection('edge', SAMPLE_IMAGE)
            });
            controls.appendChild(sampleBtn);

            // Low threshold slider
            const lowSlider = UIComponents.createRangeSlider({
                id: 'edge-low',
                label: 'Low Threshold',
                min: 0,
                max: 255,
                value: 50,
                onChange: (val) => { edgeLowThreshold = val; }
            });
            controls.appendChild(lowSlider);

            // High threshold slider
            const highSlider = UIComponents.createRangeSlider({
                id: 'edge-high',
                label: 'High Threshold',
                min: 0,
                max: 255,
                value: 150,
                onChange: (val) => { edgeHighThreshold = val; }
            });
            controls.appendChild(highSlider);

            // Separator
            const separator = document.createElement('div');
            separator.style.width = '1px';
            separator.style.height = '30px';
            separator.style.background = 'var(--border-color)';
            controls.appendChild(separator);

            // Edge detection buttons
            const edgeTypes = [
                { text: 'Canny', action: 'canny' },
                { text: 'Sobel', action: 'sobel' },
                { text: 'Laplacian', action: 'laplacian' },
                { text: 'Scharr', action: 'scharr' }
            ];

            edgeTypes.forEach(({ text, action }) => {
                const btn = UIComponents.createButton({
                    text,
                    className: 'btn btn-primary',
                    onClick: () => applyEdgeDetection(action)
                });
                controls.appendChild(btn);
            });

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('edge-output', 'edges.png')
            });
            controls.appendChild(downloadBtn);
        }

        function applyEdgeDetection(action) {
            if (!sectionData.edge.mat) {
                UIComponents.showToast({ message: 'Please load an image first', type: 'warning' });
                return;
            }

            const src = sectionData.edge.mat;
            let dst = new cv.Mat();
            let gray = new cv.Mat();

            try {
                const start = performance.now();

                // Convert to grayscale first
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                switch (action) {
                    case 'canny':
                        cv.Canny(gray, dst, edgeLowThreshold, edgeHighThreshold);
                        break;
                    case 'sobel':
                        const sobelX = new cv.Mat();
                        const sobelY = new cv.Mat();
                        cv.Sobel(gray, sobelX, cv.CV_16S, 1, 0);
                        cv.Sobel(gray, sobelY, cv.CV_16S, 0, 1);
                        const absX = new cv.Mat();
                        const absY = new cv.Mat();
                        cv.convertScaleAbs(sobelX, absX);
                        cv.convertScaleAbs(sobelY, absY);
                        cv.addWeighted(absX, 0.5, absY, 0.5, 0, dst);
                        sobelX.delete();
                        sobelY.delete();
                        absX.delete();
                        absY.delete();
                        break;
                    case 'laplacian':
                        const lap = new cv.Mat();
                        cv.Laplacian(gray, lap, cv.CV_16S, 3);
                        cv.convertScaleAbs(lap, dst);
                        lap.delete();
                        break;
                    case 'scharr':
                        const scharrX = new cv.Mat();
                        const scharrY = new cv.Mat();
                        cv.Scharr(gray, scharrX, cv.CV_16S, 1, 0);
                        cv.Scharr(gray, scharrY, cv.CV_16S, 0, 1);
                        const absScharrX = new cv.Mat();
                        const absScharrY = new cv.Mat();
                        cv.convertScaleAbs(scharrX, absScharrX);
                        cv.convertScaleAbs(scharrY, absScharrY);
                        cv.addWeighted(absScharrX, 0.5, absScharrY, 0.5, 0, dst);
                        scharrX.delete();
                        scharrY.delete();
                        absScharrX.delete();
                        absScharrY.delete();
                        break;
                }

                const time = (performance.now() - start).toFixed(2);

                cv.imshow('edge-output', dst);

                // Update metrics
                UIComponents.updateMetric('edge-time', `${time}ms`);
                UIComponents.updateMetric('edge-algo', action.charAt(0).toUpperCase() + action.slice(1));

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
                gray.delete();
            }
        }

        // =====================
        // Section 4: Thresholding
        // =====================
        let thresholdValue = 127;
        let thresholdType = 'binary';

        function setupThresholdSection() {
            const controls = document.getElementById('threshold-controls');

            // Image upload
            const upload = UIComponents.createImageUpload({
                id: 'threshold-upload',
                label: 'Upload Image',
                onChange: (file) => loadImageForSection('threshold', file)
            });
            controls.appendChild(upload);

            // Sample image button
            const sampleBtn = UIComponents.createButton({
                text: 'Use Sample',
                className: 'btn btn-secondary',
                onClick: () => loadImageForSection('threshold', SAMPLE_IMAGE)
            });
            controls.appendChild(sampleBtn);

            // Threshold value slider
            const slider = UIComponents.createRangeSlider({
                id: 'threshold-slider',
                label: 'Threshold Value',
                min: 0,
                max: 255,
                value: 127,
                onChange: (val) => {
                    thresholdValue = val;
                    applyThreshold();
                }
            });
            controls.appendChild(slider);

            // Threshold type select
            const select = UIComponents.createSelect({
                id: 'threshold-type',
                label: 'Type',
                choices: [
                    { value: 'binary', label: 'Binary' },
                    { value: 'binary_inv', label: 'Binary Inv' },
                    { value: 'truncate', label: 'Truncate' },
                    { value: 'tozero', label: 'ToZero' },
                    { value: 'otsu', label: 'Otsu' },
                    { value: 'adaptive', label: 'Adaptive' }
                ],
                value: 'binary',
                onChange: (val) => {
                    thresholdType = val;
                    applyThreshold();
                }
            });
            controls.appendChild(select);

            // Apply button
            const applyBtn = UIComponents.createButton({
                text: 'Apply',
                className: 'btn btn-primary',
                onClick: () => applyThreshold()
            });
            controls.appendChild(applyBtn);

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('threshold-output', 'thresholded.png')
            });
            controls.appendChild(downloadBtn);
        }

        function applyThreshold() {
            if (!sectionData.threshold.mat) {
                return; // Silently return if no image
            }

            const src = sectionData.threshold.mat;
            let dst = new cv.Mat();
            let gray = new cv.Mat();

            try {
                const start = performance.now();

                // Convert to grayscale
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                let usedThreshold = thresholdValue;

                switch (thresholdType) {
                    case 'binary':
                        cv.threshold(gray, dst, thresholdValue, 255, cv.THRESH_BINARY);
                        break;
                    case 'binary_inv':
                        cv.threshold(gray, dst, thresholdValue, 255, cv.THRESH_BINARY_INV);
                        break;
                    case 'truncate':
                        cv.threshold(gray, dst, thresholdValue, 255, cv.THRESH_TRUNC);
                        break;
                    case 'tozero':
                        cv.threshold(gray, dst, thresholdValue, 255, cv.THRESH_TOZERO);
                        break;
                    case 'otsu':
                        usedThreshold = cv.threshold(gray, dst, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
                        break;
                    case 'adaptive':
                        cv.adaptiveThreshold(gray, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
                        usedThreshold = 'Adaptive';
                        break;
                }

                const time = (performance.now() - start).toFixed(2);

                cv.imshow('threshold-output', dst);

                // Update metrics
                UIComponents.updateMetric('threshold-time', `${time}ms`);
                UIComponents.updateMetric('threshold-val', typeof usedThreshold === 'number' ? Math.round(usedThreshold) : usedThreshold);

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
                gray.delete();
            }
        }

        // =====================
        // Section 5: Morphological Operations
        // =====================
        let morphKernelSize = 5;
        let morphKernelShape = 'rect';

        function setupMorphSection() {
            const controls = document.getElementById('morph-controls');

            // Image upload
            const upload = UIComponents.createImageUpload({
                id: 'morph-upload',
                label: 'Upload Image',
                onChange: (file) => loadImageForSection('morph', file)
            });
            controls.appendChild(upload);

            // Sample image button
            const sampleBtn = UIComponents.createButton({
                text: 'Use Sample',
                className: 'btn btn-secondary',
                onClick: () => loadImageForSection('morph', SAMPLE_IMAGE)
            });
            controls.appendChild(sampleBtn);

            // Kernel size slider
            const slider = UIComponents.createRangeSlider({
                id: 'morph-kernel',
                label: 'Kernel Size',
                min: 3,
                max: 21,
                value: 5,
                step: 2,
                onChange: (val) => { morphKernelSize = val; }
            });
            controls.appendChild(slider);

            // Kernel shape select
            const select = UIComponents.createSelect({
                id: 'morph-shape',
                label: 'Kernel Shape',
                choices: [
                    { value: 'rect', label: 'Rectangle' },
                    { value: 'cross', label: 'Cross' },
                    { value: 'ellipse', label: 'Ellipse' }
                ],
                value: 'rect',
                onChange: (val) => { morphKernelShape = val; }
            });
            controls.appendChild(select);

            // Separator
            const separator = document.createElement('div');
            separator.style.width = '1px';
            separator.style.height = '30px';
            separator.style.background = 'var(--border-color)';
            controls.appendChild(separator);

            // Morphological operation buttons
            const morphOps = [
                { text: 'Dilate', action: 'dilate' },
                { text: 'Erode', action: 'erode' },
                { text: 'Open', action: 'open' },
                { text: 'Close', action: 'close' },
                { text: 'Gradient', action: 'gradient' },
                { text: 'TopHat', action: 'tophat' },
                { text: 'BlackHat', action: 'blackhat' }
            ];

            morphOps.forEach(({ text, action }) => {
                const btn = UIComponents.createButton({
                    text,
                    className: 'btn btn-primary btn-sm',
                    onClick: () => applyMorphology(action)
                });
                controls.appendChild(btn);
            });

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('morph-output', 'morphology.png')
            });
            controls.appendChild(downloadBtn);
        }

        function applyMorphology(action) {
            if (!sectionData.morph.mat) {
                UIComponents.showToast({ message: 'Please load an image first', type: 'warning' });
                return;
            }

            const src = sectionData.morph.mat;
            let dst = new cv.Mat();

            try {
                const start = performance.now();

                // Create kernel based on shape
                let shape;
                switch (morphKernelShape) {
                    case 'rect': shape = cv.MORPH_RECT; break;
                    case 'cross': shape = cv.MORPH_CROSS; break;
                    case 'ellipse': shape = cv.MORPH_ELLIPSE; break;
                    default: shape = cv.MORPH_RECT;
                }

                const kernel = cv.getStructuringElement(shape, new cv.Size(morphKernelSize, morphKernelSize));
                const anchor = new cv.Point(-1, -1);

                switch (action) {
                    case 'dilate':
                        cv.dilate(src, dst, kernel, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());
                        break;
                    case 'erode':
                        cv.erode(src, dst, kernel, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());
                        break;
                    case 'open':
                        cv.morphologyEx(src, dst, cv.MORPH_OPEN, kernel);
                        break;
                    case 'close':
                        cv.morphologyEx(src, dst, cv.MORPH_CLOSE, kernel);
                        break;
                    case 'gradient':
                        cv.morphologyEx(src, dst, cv.MORPH_GRADIENT, kernel);
                        break;
                    case 'tophat':
                        cv.morphologyEx(src, dst, cv.MORPH_TOPHAT, kernel);
                        break;
                    case 'blackhat':
                        cv.morphologyEx(src, dst, cv.MORPH_BLACKHAT, kernel);
                        break;
                }

                kernel.delete();

                const time = (performance.now() - start).toFixed(2);

                cv.imshow('morph-output', dst);

                // Update metrics
                UIComponents.updateMetric('morph-time', `${time}ms`);
                UIComponents.updateMetric('morph-op', action.charAt(0).toUpperCase() + action.slice(1));

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
            }
        }

        // =====================
        // Section 6: Histogram
        // =====================
        let histogramMode = 'gray';

        function setupHistogramSection() {
            const controls = document.getElementById('histogram-controls');

            // Image upload
            const upload = UIComponents.createImageUpload({
                id: 'histogram-upload',
                label: 'Upload Image',
                onChange: async (file) => {
                    await loadImageForSection('histogram', file);
                    drawHistograms();
                }
            });
            controls.appendChild(upload);

            // Sample image button
            const sampleBtn = UIComponents.createButton({
                text: 'Use Sample',
                className: 'btn btn-secondary',
                onClick: async () => {
                    await loadImageForSection('histogram', SAMPLE_IMAGE);
                    drawHistograms();
                }
            });
            controls.appendChild(sampleBtn);

            // Mode select
            const select = UIComponents.createSelect({
                id: 'histogram-mode-select',
                label: 'Mode',
                choices: [
                    { value: 'gray', label: 'Grayscale' },
                    { value: 'all', label: 'RGB Channels' }
                ],
                value: 'gray',
                onChange: (val) => {
                    histogramMode = val;
                    drawHistograms();
                }
            });
            controls.appendChild(select);

            // Separator
            const separator = document.createElement('div');
            separator.style.width = '1px';
            separator.style.height = '30px';
            separator.style.background = 'var(--border-color)';
            controls.appendChild(separator);

            // Equalize button
            const equalizeBtn = UIComponents.createButton({
                text: 'Equalize Histogram',
                className: 'btn btn-primary',
                onClick: () => equalizeHistogram()
            });
            controls.appendChild(equalizeBtn);

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('histogram-output', 'equalized.png')
            });
            controls.appendChild(downloadBtn);
        }

        function drawHistograms() {
            if (!sectionData.histogram.mat) {
                return;
            }

            const src = sectionData.histogram.mat;
            const chartCanvas = document.getElementById('histogram-chart');

            try {
                Utils.drawHistogram(src, chartCanvas, histogramMode);
                UIComponents.updateMetric('histogram-mode', histogramMode === 'gray' ? 'Grayscale' : 'RGB');
            } catch (error) {
                UIComponents.showToast({ message: 'Error drawing histogram: ' + error.message, type: 'error' });
            }
        }

        function equalizeHistogram() {
            if (!sectionData.histogram.mat) {
                UIComponents.showToast({ message: 'Please load an image first', type: 'warning' });
                return;
            }

            const src = sectionData.histogram.mat;
            let dst = new cv.Mat();

            try {
                const start = performance.now();

                if (histogramMode === 'gray' || src.channels() === 1) {
                    // Grayscale equalization
                    let gray = new cv.Mat();
                    if (src.channels() > 1) {
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    } else {
                        gray = src.clone();
                    }
                    cv.equalizeHist(gray, dst);
                    gray.delete();
                } else {
                    // Color equalization (equalize each channel)
                    let ycrcb = new cv.Mat();
                    let rgb = new cv.Mat();
                    cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);
                    cv.cvtColor(rgb, ycrcb, cv.COLOR_RGB2YCrCb);

                    let channels = new cv.MatVector();
                    cv.split(ycrcb, channels);

                    // Equalize the Y channel
                    let yChannel = channels.get(0);
                    cv.equalizeHist(yChannel, yChannel);

                    cv.merge(channels, ycrcb);
                    cv.cvtColor(ycrcb, dst, cv.COLOR_YCrCb2RGB);
                    cv.cvtColor(dst, dst, cv.COLOR_RGB2RGBA);

                    // Clean up
                    for (let i = 0; i < channels.size(); i++) {
                        channels.get(i).delete();
                    }
                    channels.delete();
                    ycrcb.delete();
                    rgb.delete();
                }

                const time = (performance.now() - start).toFixed(2);

                // Resize output canvas
                const outputCanvas = document.getElementById('histogram-output');
                outputCanvas.width = dst.cols;
                outputCanvas.height = dst.rows;

                cv.imshow('histogram-output', dst);

                // Draw equalized histogram
                const eqChartCanvas = document.getElementById('histogram-eq-chart');
                Utils.drawHistogram(dst, eqChartCanvas, histogramMode);

                // Update metrics
                UIComponents.updateMetric('histogram-time', `${time}ms`);

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
            }
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            Object.values(sectionData).forEach(data => {
                if (data.mat) {
                    try {
                        data.mat.delete();
                    } catch (e) {
                        // Ignore cleanup errors
                    }
                }
            });
        });

        // Start the app
        init();
    </script>
</body>
</html>
