<!DOCTYPE html>
<html lang="en">
<head>
    <script src="../coi-serviceworker.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Image Processing - OpenCV.js Demos</title>
    <link rel="stylesheet" href="../css/theme.css">
</head>
<body>
    <div class="container">
        <!-- Breadcrumb Navigation -->
        <nav class="nav-breadcrumb">
            <a href="../index.html">Home</a>
            <span>/</span>
            <span class="current">Core Image Processing</span>
        </nav>

        <!-- Page Header -->
        <header class="page-header">
            <h1>Core Image Processing</h1>
            <p>Color conversion, filtering, edge detection, thresholding, morphology, histograms.</p>
        </header>

        <!-- Live Processing Section -->
        <section class="demo-section" id="live-section">
            <h3>Real-Time Processing</h3>

            <div class="demo-controls" id="live-controls">
                <div class="flex gap-md items-center flex-wrap">
                    <button id="live-start" class="btn btn-success">Start Camera</button>
                    <button id="live-stop" class="btn btn-danger hidden">Stop Camera</button>

                    <select id="live-filter" class="form-control" style="min-width: 150px;">
                        <optgroup label="Color">
                            <option value="none">Original</option>
                            <option value="grayscale">Grayscale</option>
                            <option value="hsv">HSV</option>
                            <option value="invert">Invert</option>
                        </optgroup>
                        <optgroup label="Blur">
                            <option value="gaussian">Gaussian Blur</option>
                            <option value="median">Median Blur</option>
                            <option value="bilateral">Bilateral Filter</option>
                        </optgroup>
                        <optgroup label="Edge Detection">
                            <option value="canny" selected>Canny Edges</option>
                            <option value="sobel">Sobel</option>
                            <option value="laplacian">Laplacian</option>
                        </optgroup>
                        <optgroup label="Threshold">
                            <option value="binary">Binary Threshold</option>
                            <option value="adaptive">Adaptive Threshold</option>
                        </optgroup>
                        <optgroup label="Morphology">
                            <option value="dilate">Dilate</option>
                            <option value="erode">Erode</option>
                            <option value="gradient">Morphological Gradient</option>
                        </optgroup>
                        <optgroup label="Artistic">
                            <option value="sketch">Pencil Sketch</option>
                            <option value="cartoon">Cartoon</option>
                        </optgroup>
                    </select>

                    <div class="form-group" style="margin: 0;">
                        <label for="live-intensity" style="font-size: 0.85rem;">Intensity</label>
                        <input type="range" id="live-intensity" min="1" max="31" value="5" step="2" style="width: 100px;">
                    </div>
                </div>
            </div>

            <div class="demo-output">
                <div class="canvas-container" style="position: relative;">
                    <video id="live-video" autoplay playsinline muted style="display: none;"></video>
                    <canvas id="live-canvas" width="640" height="480"></canvas>
                    <span class="canvas-label" id="live-fps">FPS: --</span>
                </div>
            </div>

            <div class="metrics">
                <div class="metric">
                    <span class="metric-label">FPS</span>
                    <span class="metric-value" id="live-fps-value">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="live-proc-time">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Filter</span>
                    <span class="metric-value" id="live-filter-name">--</span>
                </div>
            </div>
        </section>

        <!-- Section 1: Color Conversion -->
        <section class="demo-section" id="color-section">
            <h3>Color Conversion</h3>

            <div class="demo-controls" id="color-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="color-input"></canvas>
                    <span class="canvas-label">Original</span>
                </div>
                <div class="canvas-container">
                    <canvas id="color-output"></canvas>
                    <span class="canvas-label">Result</span>
                </div>
            </div>

            <div class="metrics" id="color-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="color-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Image Size</span>
                    <span class="metric-value" id="color-size">-</span>
                </div>
            </div>
        </section>

        <!-- Section 2: Blur & Smoothing -->
        <section class="demo-section" id="blur-section">
            <h3>Blur & Smoothing</h3>

            <div class="demo-controls" id="blur-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="blur-input"></canvas>
                    <span class="canvas-label">Before</span>
                </div>
                <div class="canvas-container">
                    <canvas id="blur-output"></canvas>
                    <span class="canvas-label">After</span>
                </div>
            </div>

            <div class="metrics" id="blur-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="blur-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Kernel Size</span>
                    <span class="metric-value" id="blur-kernel-display">-</span>
                </div>
            </div>
        </section>

        <!-- Section 3: Edge Detection -->
        <section class="demo-section" id="edge-section">
            <h3>Edge Detection</h3>

            <div class="demo-controls" id="edge-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="edge-input"></canvas>
                    <span class="canvas-label">Original</span>
                </div>
                <div class="canvas-container">
                    <canvas id="edge-output"></canvas>
                    <span class="canvas-label">Edges</span>
                </div>
            </div>

            <div class="metrics" id="edge-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="edge-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Algorithm</span>
                    <span class="metric-value" id="edge-algo">-</span>
                </div>
            </div>
        </section>

        <!-- Section 4: Thresholding -->
        <section class="demo-section" id="threshold-section">
            <h3>Thresholding</h3>

            <div class="demo-controls" id="threshold-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="threshold-input"></canvas>
                    <span class="canvas-label">Original</span>
                </div>
                <div class="canvas-container">
                    <canvas id="threshold-output"></canvas>
                    <span class="canvas-label">Thresholded</span>
                </div>
            </div>

            <div class="metrics" id="threshold-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="threshold-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Threshold Value</span>
                    <span class="metric-value" id="threshold-val">-</span>
                </div>
            </div>
        </section>

        <!-- Section 5: Morphological Operations -->
        <section class="demo-section" id="morph-section">
            <h3>Morphology</h3>

            <div class="demo-controls" id="morph-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="morph-input"></canvas>
                    <span class="canvas-label">Original</span>
                </div>
                <div class="canvas-container">
                    <canvas id="morph-output"></canvas>
                    <span class="canvas-label">Result</span>
                </div>
            </div>

            <div class="metrics" id="morph-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="morph-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Operation</span>
                    <span class="metric-value" id="morph-op">-</span>
                </div>
            </div>
        </section>

        <!-- Section 6: Histogram -->
        <section class="demo-section" id="histogram-section">
            <h3>Histogram</h3>

            <div class="demo-controls" id="histogram-controls">
                <!-- Controls will be generated by JavaScript -->
            </div>

            <div class="demo-output">
                <div class="canvas-container">
                    <canvas id="histogram-input"></canvas>
                    <span class="canvas-label">Image</span>
                </div>
                <div class="canvas-container">
                    <canvas id="histogram-chart" width="512" height="200"></canvas>
                    <span class="canvas-label">Histogram</span>
                </div>
            </div>

            <div class="demo-output mt-md">
                <div class="canvas-container">
                    <canvas id="histogram-output"></canvas>
                    <span class="canvas-label">Equalized</span>
                </div>
                <div class="canvas-container">
                    <canvas id="histogram-eq-chart" width="512" height="200"></canvas>
                    <span class="canvas-label">Equalized Histogram</span>
                </div>
            </div>

            <div class="metrics" id="histogram-metrics">
                <div class="metric">
                    <span class="metric-label">Processing Time</span>
                    <span class="metric-value" id="histogram-time">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Mode</span>
                    <span class="metric-value" id="histogram-mode">-</span>
                </div>
            </div>
        </section>
    </div>

    <!-- Scripts -->
    <script src="../js/opencv-loader.js"></script>
    <script src="../js/utils.js"></script>
    <script src="../js/ui-components.js"></script>

    <script>
        // Store loaded images for each section
        const sectionData = {
            color: { mat: null },
            blur: { mat: null },
            edge: { mat: null },
            threshold: { mat: null },
            morph: { mat: null },
            histogram: { mat: null }
        };

        // Sample image URL
        const SAMPLE_IMAGE = '../images/lena.png';

        // Initialize the page
        async function init() {
            try {
                await UIComponents.initPage({
                    title: 'Core Image Processing',
                    buildType: 'full'
                });

                setupLiveSection();
                setupColorSection();
                setupBlurSection();
                setupEdgeSection();
                setupThresholdSection();
                setupMorphSection();
                setupHistogramSection();

            } catch (error) {
                console.error('Failed to initialize:', error);
                UIComponents.showToast({
                    message: 'Failed to load OpenCV.js: ' + error.message,
                    type: 'error',
                    duration: 5000
                });
            }
        }

        // Helper: Load image for a section (supports File, URL, or cv.Mat)
        async function loadImageForSection(section, source) {
            try {
                // Clean up previous mat
                if (sectionData[section].mat) {
                    sectionData[section].mat.delete();
                }

                let mat;
                let width, height;

                if (source && source.rows !== undefined && source.cols !== undefined && typeof source.clone === 'function') {
                    // Source is already a cv.Mat (from webcam capture)
                    mat = source.clone();
                    width = mat.cols;
                    height = mat.rows;
                } else {
                    // Source is a File or URL
                    const img = await Utils.loadImage(source);
                    mat = Utils.imageToMat(img);
                    width = img.width;
                    height = img.height;
                }

                sectionData[section].mat = mat;

                // Display on input canvas
                const inputCanvas = document.getElementById(`${section}-input`);
                inputCanvas.width = width;
                inputCanvas.height = height;
                cv.imshow(inputCanvas, sectionData[section].mat);

                // Resize output canvas
                const outputCanvas = document.getElementById(`${section}-output`);
                if (outputCanvas) {
                    outputCanvas.width = width;
                    outputCanvas.height = height;
                }

                return true;
            } catch (error) {
                UIComponents.showToast({
                    message: 'Failed to load image: ' + error.message,
                    type: 'error'
                });
                return false;
            }
        }

        // Helper: Download result
        function downloadResult(canvasId, filename) {
            Utils.downloadCanvas(canvasId, filename);
            UIComponents.showToast({
                message: 'Image downloaded',
                type: 'success'
            });
        }

        // =====================
        // Live Processing Section
        // =====================
        const liveState = {
            stream: null,
            video: null,
            canvas: null,
            ctx: null,
            animationId: null,
            running: false,
            lastTime: 0,
            frameCount: 0,
            fps: 0
        };

        function setupLiveSection() {
            liveState.video = document.getElementById('live-video');
            liveState.canvas = document.getElementById('live-canvas');
            liveState.ctx = liveState.canvas.getContext('2d');

            document.getElementById('live-start').addEventListener('click', startLiveProcessing);
            document.getElementById('live-stop').addEventListener('click', stopLiveProcessing);

            document.getElementById('live-filter').addEventListener('change', (e) => {
                document.getElementById('live-filter-name').textContent = e.target.options[e.target.selectedIndex].text;
            });
        }

        async function startLiveProcessing() {
            try {
                liveState.stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' },
                    audio: false
                });

                liveState.video.srcObject = liveState.stream;
                await liveState.video.play();

                liveState.canvas.width = liveState.video.videoWidth;
                liveState.canvas.height = liveState.video.videoHeight;

                liveState.running = true;
                liveState.lastTime = performance.now();
                liveState.frameCount = 0;

                document.getElementById('live-start').classList.add('hidden');
                document.getElementById('live-stop').classList.remove('hidden');
                document.getElementById('live-filter-name').textContent =
                    document.getElementById('live-filter').options[document.getElementById('live-filter').selectedIndex].text;

                processLiveFrame();
            } catch (error) {
                UIComponents.showToast({ message: 'Webcam access denied: ' + error.message, type: 'error' });
            }
        }

        function stopLiveProcessing() {
            liveState.running = false;
            if (liveState.animationId) {
                cancelAnimationFrame(liveState.animationId);
                liveState.animationId = null;
            }
            if (liveState.stream) {
                liveState.stream.getTracks().forEach(track => track.stop());
                liveState.stream = null;
            }
            liveState.video.srcObject = null;

            document.getElementById('live-stop').classList.add('hidden');
            document.getElementById('live-start').classList.remove('hidden');
            document.getElementById('live-fps-value').textContent = '--';
            document.getElementById('live-proc-time').textContent = '--';

            // Clear canvas
            liveState.ctx.fillStyle = '#1a1a24';
            liveState.ctx.fillRect(0, 0, liveState.canvas.width, liveState.canvas.height);
        }

        function processLiveFrame() {
            if (!liveState.running) return;

            const procStart = performance.now();

            // Update FPS
            liveState.frameCount++;
            if (procStart - liveState.lastTime >= 1000) {
                liveState.fps = liveState.frameCount;
                liveState.frameCount = 0;
                liveState.lastTime = procStart;
                document.getElementById('live-fps-value').textContent = liveState.fps;
            }

            // Capture frame
            liveState.ctx.drawImage(liveState.video, 0, 0);

            const filter = document.getElementById('live-filter').value;
            const intensity = parseInt(document.getElementById('live-intensity').value);

            if (filter !== 'none') {
                let src = cv.imread(liveState.canvas);
                let dst = new cv.Mat();

                try {
                    applyLiveFilter(src, dst, filter, intensity);
                    cv.imshow(liveState.canvas, dst);
                } catch (e) {
                    console.error('Filter error:', e);
                }

                src.delete();
                dst.delete();
            }

            const procTime = (performance.now() - procStart).toFixed(1);
            document.getElementById('live-proc-time').textContent = procTime + 'ms';

            liveState.animationId = requestAnimationFrame(processLiveFrame);
        }

        function applyLiveFilter(src, dst, filter, intensity) {
            let gray = new cv.Mat();
            const ksize = intensity | 1; // Ensure odd number

            switch (filter) {
                // Color filters
                case 'grayscale':
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
                    cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGBA);
                    break;
                case 'hsv':
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2RGB);
                    cv.cvtColor(dst, dst, cv.COLOR_RGB2HSV);
                    break;
                case 'invert':
                    cv.bitwise_not(src, dst);
                    break;

                // Blur filters
                case 'gaussian':
                    cv.GaussianBlur(src, dst, new cv.Size(ksize, ksize), 0);
                    break;
                case 'median':
                    cv.medianBlur(src, dst, ksize);
                    break;
                case 'bilateral':
                    const rgb = new cv.Mat();
                    cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);
                    const bilat = new cv.Mat();
                    cv.bilateralFilter(rgb, bilat, ksize, ksize * 2, ksize / 2);
                    cv.cvtColor(bilat, dst, cv.COLOR_RGB2RGBA);
                    rgb.delete();
                    bilat.delete();
                    break;

                // Edge detection
                case 'canny':
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    cv.Canny(gray, dst, 50, 150);
                    cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGBA);
                    break;
                case 'sobel':
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    const sobelX = new cv.Mat();
                    const sobelY = new cv.Mat();
                    cv.Sobel(gray, sobelX, cv.CV_16S, 1, 0);
                    cv.Sobel(gray, sobelY, cv.CV_16S, 0, 1);
                    cv.convertScaleAbs(sobelX, sobelX);
                    cv.convertScaleAbs(sobelY, sobelY);
                    cv.addWeighted(sobelX, 0.5, sobelY, 0.5, 0, dst);
                    cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGBA);
                    sobelX.delete();
                    sobelY.delete();
                    break;
                case 'laplacian':
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    const lap = new cv.Mat();
                    cv.Laplacian(gray, lap, cv.CV_16S, ksize);
                    cv.convertScaleAbs(lap, dst);
                    cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGBA);
                    lap.delete();
                    break;

                // Threshold
                case 'binary':
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    cv.threshold(gray, dst, 127, 255, cv.THRESH_BINARY);
                    cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGBA);
                    break;
                case 'adaptive':
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    cv.adaptiveThreshold(gray, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
                    cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGBA);
                    break;

                // Morphology
                case 'dilate':
                    const dilateKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(ksize, ksize));
                    cv.dilate(src, dst, dilateKernel);
                    dilateKernel.delete();
                    break;
                case 'erode':
                    const erodeKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(ksize, ksize));
                    cv.erode(src, dst, erodeKernel);
                    erodeKernel.delete();
                    break;
                case 'gradient':
                    const gradKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(ksize, ksize));
                    cv.morphologyEx(src, dst, cv.MORPH_GRADIENT, gradKernel);
                    gradKernel.delete();
                    break;

                // Artistic
                case 'sketch':
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    cv.GaussianBlur(gray, gray, new cv.Size(21, 21), 0);
                    const invGray = new cv.Mat();
                    cv.bitwise_not(gray, invGray);
                    cv.divide(gray, invGray, dst, 256);
                    cv.cvtColor(dst, dst, cv.COLOR_GRAY2RGBA);
                    invGray.delete();
                    break;
                case 'cartoon':
                    // Bilateral filter + edge overlay
                    const cartoonRgb = new cv.Mat();
                    cv.cvtColor(src, cartoonRgb, cv.COLOR_RGBA2RGB);
                    const bilateral = new cv.Mat();
                    cv.bilateralFilter(cartoonRgb, bilateral, 9, 75, 75);
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    cv.medianBlur(gray, gray, 7);
                    const edges = new cv.Mat();
                    cv.adaptiveThreshold(gray, edges, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 9, 2);
                    cv.cvtColor(edges, edges, cv.COLOR_GRAY2RGB);
                    cv.bitwise_and(bilateral, edges, dst);
                    cv.cvtColor(dst, dst, cv.COLOR_RGB2RGBA);
                    cartoonRgb.delete();
                    bilateral.delete();
                    edges.delete();
                    break;

                default:
                    src.copyTo(dst);
            }

            gray.delete();
        }

        // =====================
        // Section 1: Color Conversion
        // =====================
        function setupColorSection() {
            const controls = document.getElementById('color-controls');

            // Input source selector (Upload + Webcam)
            const inputSource = UIComponents.createInputSourceSelector({
                id: 'color-input-source',
                onImageLoad: (source) => loadImageForSection('color', source),
                showCapture: true
            });
            controls.appendChild(inputSource);

            // Separator
            const separator = document.createElement('div');
            separator.style.width = '1px';
            separator.style.height = '30px';
            separator.style.background = 'var(--border-color)';
            controls.appendChild(separator);

            // Conversion buttons
            const conversions = [
                { text: 'Grayscale', action: 'gray' },
                { text: 'HSV', action: 'hsv' },
                { text: 'LAB', action: 'lab' },
                { text: 'RGB Channels', action: 'channels' }
            ];

            conversions.forEach(({ text, action }) => {
                const btn = UIComponents.createButton({
                    text,
                    className: 'btn btn-primary',
                    onClick: () => applyColorConversion(action)
                });
                controls.appendChild(btn);
            });

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('color-output', 'color-converted.png')
            });
            controls.appendChild(downloadBtn);
        }

        function applyColorConversion(action) {
            if (!sectionData.color.mat) {
                UIComponents.showToast({ message: 'Please load an image first', type: 'warning' });
                return;
            }

            const src = sectionData.color.mat;
            let dst = new cv.Mat();

            try {
                const start = performance.now();

                switch (action) {
                    case 'gray':
                        cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
                        break;
                    case 'hsv':
                        const rgb = new cv.Mat();
                        cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);
                        cv.cvtColor(rgb, dst, cv.COLOR_RGB2HSV);
                        rgb.delete();
                        break;
                    case 'lab':
                        const rgb2 = new cv.Mat();
                        cv.cvtColor(src, rgb2, cv.COLOR_RGBA2RGB);
                        cv.cvtColor(rgb2, dst, cv.COLOR_RGB2Lab);
                        rgb2.delete();
                        break;
                    case 'channels':
                        // Split into RGB channels and display side by side
                        const channels = new cv.MatVector();
                        cv.split(src, channels);

                        const width = src.cols;
                        const height = src.rows;
                        dst = new cv.Mat(height, width * 3, cv.CV_8UC1);

                        // Copy each channel to a region
                        const r = channels.get(0);
                        const g = channels.get(1);
                        const b = channels.get(2);

                        r.copyTo(dst.roi(new cv.Rect(0, 0, width, height)));
                        g.copyTo(dst.roi(new cv.Rect(width, 0, width, height)));
                        b.copyTo(dst.roi(new cv.Rect(width * 2, 0, width, height)));

                        // Clean up
                        for (let i = 0; i < channels.size(); i++) {
                            channels.get(i).delete();
                        }
                        channels.delete();
                        break;
                }

                const time = (performance.now() - start).toFixed(2);

                // Update output canvas size for channels view
                const outputCanvas = document.getElementById('color-output');
                outputCanvas.width = dst.cols;
                outputCanvas.height = dst.rows;

                cv.imshow('color-output', dst);

                // Update metrics
                UIComponents.updateMetric('color-time', `${time}ms`);
                UIComponents.updateMetric('color-size', `${src.cols}x${src.rows}`);

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
            }
        }

        // =====================
        // Section 2: Blur & Smoothing
        // =====================
        let blurKernelSize = 5;

        function setupBlurSection() {
            const controls = document.getElementById('blur-controls');

            // Input source selector (Upload + Webcam)
            const inputSource = UIComponents.createInputSourceSelector({
                id: 'blur-input-source',
                onImageLoad: (source) => loadImageForSection('blur', source),
                showCapture: true
            });
            controls.appendChild(inputSource);

            // Kernel size slider (odd values only: 3, 5, 7, ... 31)
            const slider = UIComponents.createRangeSlider({
                id: 'blur-kernel',
                label: 'Kernel Size',
                min: 3,
                max: 31,
                value: 5,
                step: 2,
                onChange: (val) => { blurKernelSize = val; }
            });
            controls.appendChild(slider);

            // Separator
            const separator = document.createElement('div');
            separator.style.width = '1px';
            separator.style.height = '30px';
            separator.style.background = 'var(--border-color)';
            controls.appendChild(separator);

            // Blur type buttons
            const blurTypes = [
                { text: 'Gaussian', action: 'gaussian' },
                { text: 'Median', action: 'median' },
                { text: 'Bilateral', action: 'bilateral' },
                { text: 'Box Blur', action: 'box' }
            ];

            blurTypes.forEach(({ text, action }) => {
                const btn = UIComponents.createButton({
                    text,
                    className: 'btn btn-primary',
                    onClick: () => applyBlur(action)
                });
                controls.appendChild(btn);
            });

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('blur-output', 'blurred.png')
            });
            controls.appendChild(downloadBtn);
        }

        function applyBlur(action) {
            if (!sectionData.blur.mat) {
                UIComponents.showToast({ message: 'Please load an image first', type: 'warning' });
                return;
            }

            const src = sectionData.blur.mat;
            let dst = new cv.Mat();

            try {
                const start = performance.now();
                const ksize = blurKernelSize;

                switch (action) {
                    case 'gaussian':
                        cv.GaussianBlur(src, dst, new cv.Size(ksize, ksize), 0);
                        break;
                    case 'median':
                        cv.medianBlur(src, dst, ksize);
                        break;
                    case 'bilateral':
                        const rgb = new cv.Mat();
                        cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);
                        const bilateralDst = new cv.Mat();
                        cv.bilateralFilter(rgb, bilateralDst, ksize, ksize * 2, ksize / 2);
                        cv.cvtColor(bilateralDst, dst, cv.COLOR_RGB2RGBA);
                        rgb.delete();
                        bilateralDst.delete();
                        break;
                    case 'box':
                        cv.blur(src, dst, new cv.Size(ksize, ksize));
                        break;
                }

                const time = (performance.now() - start).toFixed(2);

                cv.imshow('blur-output', dst);

                // Update metrics
                UIComponents.updateMetric('blur-time', `${time}ms`);
                UIComponents.updateMetric('blur-kernel-display', `${ksize}x${ksize}`);

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
            }
        }

        // =====================
        // Section 3: Edge Detection
        // =====================
        let edgeLowThreshold = 50;
        let edgeHighThreshold = 150;

        function setupEdgeSection() {
            const controls = document.getElementById('edge-controls');

            // Image upload
            const upload = UIComponents.createImageUpload({
                id: 'edge-upload',
                label: 'Upload Image',
                onChange: (file) => loadImageForSection('edge', file)
            });
            controls.appendChild(upload);

            // Sample image button
            const sampleBtn = UIComponents.createButton({
                text: 'Use Sample',
                className: 'btn btn-secondary',
                onClick: () => loadImageForSection('edge', SAMPLE_IMAGE)
            });
            controls.appendChild(sampleBtn);

            // Low threshold slider
            const lowSlider = UIComponents.createRangeSlider({
                id: 'edge-low',
                label: 'Low Threshold',
                min: 0,
                max: 255,
                value: 50,
                onChange: (val) => { edgeLowThreshold = val; }
            });
            controls.appendChild(lowSlider);

            // High threshold slider
            const highSlider = UIComponents.createRangeSlider({
                id: 'edge-high',
                label: 'High Threshold',
                min: 0,
                max: 255,
                value: 150,
                onChange: (val) => { edgeHighThreshold = val; }
            });
            controls.appendChild(highSlider);

            // Separator
            const separator = document.createElement('div');
            separator.style.width = '1px';
            separator.style.height = '30px';
            separator.style.background = 'var(--border-color)';
            controls.appendChild(separator);

            // Edge detection buttons
            const edgeTypes = [
                { text: 'Canny', action: 'canny' },
                { text: 'Sobel', action: 'sobel' },
                { text: 'Laplacian', action: 'laplacian' },
                { text: 'Scharr', action: 'scharr' }
            ];

            edgeTypes.forEach(({ text, action }) => {
                const btn = UIComponents.createButton({
                    text,
                    className: 'btn btn-primary',
                    onClick: () => applyEdgeDetection(action)
                });
                controls.appendChild(btn);
            });

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('edge-output', 'edges.png')
            });
            controls.appendChild(downloadBtn);
        }

        function applyEdgeDetection(action) {
            if (!sectionData.edge.mat) {
                UIComponents.showToast({ message: 'Please load an image first', type: 'warning' });
                return;
            }

            const src = sectionData.edge.mat;
            let dst = new cv.Mat();
            let gray = new cv.Mat();

            try {
                const start = performance.now();

                // Convert to grayscale first
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                switch (action) {
                    case 'canny':
                        cv.Canny(gray, dst, edgeLowThreshold, edgeHighThreshold);
                        break;
                    case 'sobel':
                        const sobelX = new cv.Mat();
                        const sobelY = new cv.Mat();
                        cv.Sobel(gray, sobelX, cv.CV_16S, 1, 0);
                        cv.Sobel(gray, sobelY, cv.CV_16S, 0, 1);
                        const absX = new cv.Mat();
                        const absY = new cv.Mat();
                        cv.convertScaleAbs(sobelX, absX);
                        cv.convertScaleAbs(sobelY, absY);
                        cv.addWeighted(absX, 0.5, absY, 0.5, 0, dst);
                        sobelX.delete();
                        sobelY.delete();
                        absX.delete();
                        absY.delete();
                        break;
                    case 'laplacian':
                        const lap = new cv.Mat();
                        cv.Laplacian(gray, lap, cv.CV_16S, 3);
                        cv.convertScaleAbs(lap, dst);
                        lap.delete();
                        break;
                    case 'scharr':
                        const scharrX = new cv.Mat();
                        const scharrY = new cv.Mat();
                        cv.Scharr(gray, scharrX, cv.CV_16S, 1, 0);
                        cv.Scharr(gray, scharrY, cv.CV_16S, 0, 1);
                        const absScharrX = new cv.Mat();
                        const absScharrY = new cv.Mat();
                        cv.convertScaleAbs(scharrX, absScharrX);
                        cv.convertScaleAbs(scharrY, absScharrY);
                        cv.addWeighted(absScharrX, 0.5, absScharrY, 0.5, 0, dst);
                        scharrX.delete();
                        scharrY.delete();
                        absScharrX.delete();
                        absScharrY.delete();
                        break;
                }

                const time = (performance.now() - start).toFixed(2);

                cv.imshow('edge-output', dst);

                // Update metrics
                UIComponents.updateMetric('edge-time', `${time}ms`);
                UIComponents.updateMetric('edge-algo', action.charAt(0).toUpperCase() + action.slice(1));

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
                gray.delete();
            }
        }

        // =====================
        // Section 4: Thresholding
        // =====================
        let thresholdValue = 127;
        let thresholdType = 'binary';

        function setupThresholdSection() {
            const controls = document.getElementById('threshold-controls');

            // Image upload
            const upload = UIComponents.createImageUpload({
                id: 'threshold-upload',
                label: 'Upload Image',
                onChange: (file) => loadImageForSection('threshold', file)
            });
            controls.appendChild(upload);

            // Sample image button
            const sampleBtn = UIComponents.createButton({
                text: 'Use Sample',
                className: 'btn btn-secondary',
                onClick: () => loadImageForSection('threshold', SAMPLE_IMAGE)
            });
            controls.appendChild(sampleBtn);

            // Threshold value slider
            const slider = UIComponents.createRangeSlider({
                id: 'threshold-slider',
                label: 'Threshold Value',
                min: 0,
                max: 255,
                value: 127,
                onChange: (val) => {
                    thresholdValue = val;
                    applyThreshold();
                }
            });
            controls.appendChild(slider);

            // Threshold type select
            const select = UIComponents.createSelect({
                id: 'threshold-type',
                label: 'Type',
                choices: [
                    { value: 'binary', label: 'Binary' },
                    { value: 'binary_inv', label: 'Binary Inv' },
                    { value: 'truncate', label: 'Truncate' },
                    { value: 'tozero', label: 'ToZero' },
                    { value: 'otsu', label: 'Otsu' },
                    { value: 'adaptive', label: 'Adaptive' }
                ],
                value: 'binary',
                onChange: (val) => {
                    thresholdType = val;
                    applyThreshold();
                }
            });
            controls.appendChild(select);

            // Apply button
            const applyBtn = UIComponents.createButton({
                text: 'Apply',
                className: 'btn btn-primary',
                onClick: () => applyThreshold()
            });
            controls.appendChild(applyBtn);

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('threshold-output', 'thresholded.png')
            });
            controls.appendChild(downloadBtn);
        }

        function applyThreshold() {
            if (!sectionData.threshold.mat) {
                return; // Silently return if no image
            }

            const src = sectionData.threshold.mat;
            let dst = new cv.Mat();
            let gray = new cv.Mat();

            try {
                const start = performance.now();

                // Convert to grayscale
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                let usedThreshold = thresholdValue;

                switch (thresholdType) {
                    case 'binary':
                        cv.threshold(gray, dst, thresholdValue, 255, cv.THRESH_BINARY);
                        break;
                    case 'binary_inv':
                        cv.threshold(gray, dst, thresholdValue, 255, cv.THRESH_BINARY_INV);
                        break;
                    case 'truncate':
                        cv.threshold(gray, dst, thresholdValue, 255, cv.THRESH_TRUNC);
                        break;
                    case 'tozero':
                        cv.threshold(gray, dst, thresholdValue, 255, cv.THRESH_TOZERO);
                        break;
                    case 'otsu':
                        usedThreshold = cv.threshold(gray, dst, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
                        break;
                    case 'adaptive':
                        cv.adaptiveThreshold(gray, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
                        usedThreshold = 'Adaptive';
                        break;
                }

                const time = (performance.now() - start).toFixed(2);

                cv.imshow('threshold-output', dst);

                // Update metrics
                UIComponents.updateMetric('threshold-time', `${time}ms`);
                UIComponents.updateMetric('threshold-val', typeof usedThreshold === 'number' ? Math.round(usedThreshold) : usedThreshold);

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
                gray.delete();
            }
        }

        // =====================
        // Section 5: Morphological Operations
        // =====================
        let morphKernelSize = 5;
        let morphKernelShape = 'rect';

        function setupMorphSection() {
            const controls = document.getElementById('morph-controls');

            // Image upload
            const upload = UIComponents.createImageUpload({
                id: 'morph-upload',
                label: 'Upload Image',
                onChange: (file) => loadImageForSection('morph', file)
            });
            controls.appendChild(upload);

            // Sample image button
            const sampleBtn = UIComponents.createButton({
                text: 'Use Sample',
                className: 'btn btn-secondary',
                onClick: () => loadImageForSection('morph', SAMPLE_IMAGE)
            });
            controls.appendChild(sampleBtn);

            // Kernel size slider
            const slider = UIComponents.createRangeSlider({
                id: 'morph-kernel',
                label: 'Kernel Size',
                min: 3,
                max: 21,
                value: 5,
                step: 2,
                onChange: (val) => { morphKernelSize = val; }
            });
            controls.appendChild(slider);

            // Kernel shape select
            const select = UIComponents.createSelect({
                id: 'morph-shape',
                label: 'Kernel Shape',
                choices: [
                    { value: 'rect', label: 'Rectangle' },
                    { value: 'cross', label: 'Cross' },
                    { value: 'ellipse', label: 'Ellipse' }
                ],
                value: 'rect',
                onChange: (val) => { morphKernelShape = val; }
            });
            controls.appendChild(select);

            // Separator
            const separator = document.createElement('div');
            separator.style.width = '1px';
            separator.style.height = '30px';
            separator.style.background = 'var(--border-color)';
            controls.appendChild(separator);

            // Morphological operation buttons
            const morphOps = [
                { text: 'Dilate', action: 'dilate' },
                { text: 'Erode', action: 'erode' },
                { text: 'Open', action: 'open' },
                { text: 'Close', action: 'close' },
                { text: 'Gradient', action: 'gradient' },
                { text: 'TopHat', action: 'tophat' },
                { text: 'BlackHat', action: 'blackhat' }
            ];

            morphOps.forEach(({ text, action }) => {
                const btn = UIComponents.createButton({
                    text,
                    className: 'btn btn-primary btn-sm',
                    onClick: () => applyMorphology(action)
                });
                controls.appendChild(btn);
            });

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('morph-output', 'morphology.png')
            });
            controls.appendChild(downloadBtn);
        }

        function applyMorphology(action) {
            if (!sectionData.morph.mat) {
                UIComponents.showToast({ message: 'Please load an image first', type: 'warning' });
                return;
            }

            const src = sectionData.morph.mat;
            let dst = new cv.Mat();

            try {
                const start = performance.now();

                // Create kernel based on shape
                let shape;
                switch (morphKernelShape) {
                    case 'rect': shape = cv.MORPH_RECT; break;
                    case 'cross': shape = cv.MORPH_CROSS; break;
                    case 'ellipse': shape = cv.MORPH_ELLIPSE; break;
                    default: shape = cv.MORPH_RECT;
                }

                const kernel = cv.getStructuringElement(shape, new cv.Size(morphKernelSize, morphKernelSize));
                const anchor = new cv.Point(-1, -1);

                switch (action) {
                    case 'dilate':
                        cv.dilate(src, dst, kernel, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());
                        break;
                    case 'erode':
                        cv.erode(src, dst, kernel, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());
                        break;
                    case 'open':
                        cv.morphologyEx(src, dst, cv.MORPH_OPEN, kernel);
                        break;
                    case 'close':
                        cv.morphologyEx(src, dst, cv.MORPH_CLOSE, kernel);
                        break;
                    case 'gradient':
                        cv.morphologyEx(src, dst, cv.MORPH_GRADIENT, kernel);
                        break;
                    case 'tophat':
                        cv.morphologyEx(src, dst, cv.MORPH_TOPHAT, kernel);
                        break;
                    case 'blackhat':
                        cv.morphologyEx(src, dst, cv.MORPH_BLACKHAT, kernel);
                        break;
                }

                kernel.delete();

                const time = (performance.now() - start).toFixed(2);

                cv.imshow('morph-output', dst);

                // Update metrics
                UIComponents.updateMetric('morph-time', `${time}ms`);
                UIComponents.updateMetric('morph-op', action.charAt(0).toUpperCase() + action.slice(1));

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
            }
        }

        // =====================
        // Section 6: Histogram
        // =====================
        let histogramMode = 'gray';

        function setupHistogramSection() {
            const controls = document.getElementById('histogram-controls');

            // Image upload
            const upload = UIComponents.createImageUpload({
                id: 'histogram-upload',
                label: 'Upload Image',
                onChange: async (file) => {
                    await loadImageForSection('histogram', file);
                    drawHistograms();
                }
            });
            controls.appendChild(upload);

            // Sample image button
            const sampleBtn = UIComponents.createButton({
                text: 'Use Sample',
                className: 'btn btn-secondary',
                onClick: async () => {
                    await loadImageForSection('histogram', SAMPLE_IMAGE);
                    drawHistograms();
                }
            });
            controls.appendChild(sampleBtn);

            // Mode select
            const select = UIComponents.createSelect({
                id: 'histogram-mode-select',
                label: 'Mode',
                choices: [
                    { value: 'gray', label: 'Grayscale' },
                    { value: 'all', label: 'RGB Channels' }
                ],
                value: 'gray',
                onChange: (val) => {
                    histogramMode = val;
                    drawHistograms();
                }
            });
            controls.appendChild(select);

            // Separator
            const separator = document.createElement('div');
            separator.style.width = '1px';
            separator.style.height = '30px';
            separator.style.background = 'var(--border-color)';
            controls.appendChild(separator);

            // Equalize button
            const equalizeBtn = UIComponents.createButton({
                text: 'Equalize Histogram',
                className: 'btn btn-primary',
                onClick: () => equalizeHistogram()
            });
            controls.appendChild(equalizeBtn);

            // Download button
            const downloadBtn = UIComponents.createButton({
                text: 'Download',
                className: 'btn btn-secondary',
                onClick: () => downloadResult('histogram-output', 'equalized.png')
            });
            controls.appendChild(downloadBtn);
        }

        function drawHistograms() {
            if (!sectionData.histogram.mat) {
                return;
            }

            const src = sectionData.histogram.mat;
            const chartCanvas = document.getElementById('histogram-chart');

            try {
                Utils.drawHistogram(src, chartCanvas, histogramMode);
                UIComponents.updateMetric('histogram-mode', histogramMode === 'gray' ? 'Grayscale' : 'RGB');
            } catch (error) {
                UIComponents.showToast({ message: 'Error drawing histogram: ' + error.message, type: 'error' });
            }
        }

        function equalizeHistogram() {
            if (!sectionData.histogram.mat) {
                UIComponents.showToast({ message: 'Please load an image first', type: 'warning' });
                return;
            }

            const src = sectionData.histogram.mat;
            let dst = new cv.Mat();

            try {
                const start = performance.now();

                if (histogramMode === 'gray' || src.channels() === 1) {
                    // Grayscale equalization
                    let gray = new cv.Mat();
                    if (src.channels() > 1) {
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                    } else {
                        gray = src.clone();
                    }
                    cv.equalizeHist(gray, dst);
                    gray.delete();
                } else {
                    // Color equalization (equalize each channel)
                    let ycrcb = new cv.Mat();
                    let rgb = new cv.Mat();
                    cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);
                    cv.cvtColor(rgb, ycrcb, cv.COLOR_RGB2YCrCb);

                    let channels = new cv.MatVector();
                    cv.split(ycrcb, channels);

                    // Equalize the Y channel
                    let yChannel = channels.get(0);
                    cv.equalizeHist(yChannel, yChannel);

                    cv.merge(channels, ycrcb);
                    cv.cvtColor(ycrcb, dst, cv.COLOR_YCrCb2RGB);
                    cv.cvtColor(dst, dst, cv.COLOR_RGB2RGBA);

                    // Clean up
                    for (let i = 0; i < channels.size(); i++) {
                        channels.get(i).delete();
                    }
                    channels.delete();
                    ycrcb.delete();
                    rgb.delete();
                }

                const time = (performance.now() - start).toFixed(2);

                // Resize output canvas
                const outputCanvas = document.getElementById('histogram-output');
                outputCanvas.width = dst.cols;
                outputCanvas.height = dst.rows;

                cv.imshow('histogram-output', dst);

                // Draw equalized histogram
                const eqChartCanvas = document.getElementById('histogram-eq-chart');
                Utils.drawHistogram(dst, eqChartCanvas, histogramMode);

                // Update metrics
                UIComponents.updateMetric('histogram-time', `${time}ms`);

            } catch (error) {
                UIComponents.showToast({ message: 'Error: ' + error.message, type: 'error' });
            } finally {
                dst.delete();
            }
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            Object.values(sectionData).forEach(data => {
                if (data.mat) {
                    try {
                        data.mat.delete();
                    } catch (e) {
                        // Ignore cleanup errors
                    }
                }
            });
        });

        // Start the app
        init();
    </script>
</body>
</html>
