<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCV.js Webcam Processing</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 {
            text-align: center;
            color: #00d9ff;
        }
        .controls {
            background: #16213e;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        select, button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        }
        select {
            background: #0f3460;
            color: #eee;
        }
        button {
            background: #00d9ff;
            color: #1a1a2e;
            font-weight: bold;
            transition: transform 0.1s, background 0.2s;
        }
        button:hover {
            background: #00b8d9;
            transform: scale(1.02);
        }
        button:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }
        button.stop {
            background: #e94560;
        }
        button.stop:hover {
            background: #c73e54;
        }
        #status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            background: #0f3460;
            color: #00d9ff;
        }
        #status.error {
            background: #3d1f1f;
            color: #e94560;
        }
        #status.success {
            background: #1f3d2e;
            color: #4ade80;
        }
        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }
        .video-box {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
        }
        .video-box h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #888;
        }
        video, canvas {
            width: 100%;
            border-radius: 4px;
            background: #000;
        }
        .hidden {
            display: none !important;
        }
        #fps {
            font-family: monospace;
            color: #4ade80;
            margin-left: 20px;
        }
        .filter-info {
            margin-top: 20px;
            padding: 15px;
            background: #0f3460;
            border-radius: 8px;
            font-size: 13px;
            color: #888;
        }
        .filter-info code {
            background: #1a1a2e;
            padding: 2px 6px;
            border-radius: 3px;
            color: #00d9ff;
        }
    </style>
</head>
<body>
    <h1>OpenCV.js Real-Time Webcam Processing</h1>

    <div id="status">Loading OpenCV.js...</div>

    <div class="controls">
        <div class="control-row">
            <button id="startBtn" disabled>Start Webcam</button>
            <button id="stopBtn" class="stop hidden">Stop</button>

            <select id="filterSelect">
                <option value="none">No Filter</option>
                <option value="grayscale">Grayscale</option>
                <option value="canny">Canny Edge Detection</option>
                <option value="blur">Gaussian Blur</option>
                <option value="threshold">Adaptive Threshold</option>
                <option value="invert">Invert Colors</option>
                <option value="cartoon">Cartoon Effect</option>
                <option value="sketch">Pencil Sketch</option>
                <option value="heatmap">Heat Map</option>
                <option value="pixelate">Pixelate</option>
            </select>

            <span id="fps">FPS: --</span>
        </div>
    </div>

    <div class="video-container">
        <div class="video-box">
            <h3>Webcam Input</h3>
            <video id="video" autoplay playsinline></video>
        </div>
        <div class="video-box">
            <h3>Processed Output</h3>
            <canvas id="canvasOutput"></canvas>
        </div>
    </div>

    <div class="filter-info">
        <strong>Available Filters:</strong><br><br>
        <code>Grayscale</code> - Convert to black and white<br>
        <code>Canny</code> - Edge detection algorithm<br>
        <code>Blur</code> - Gaussian blur smoothing<br>
        <code>Threshold</code> - Adaptive binary threshold<br>
        <code>Invert</code> - Invert all colors<br>
        <code>Cartoon</code> - Cartoon-style effect with edge preservation<br>
        <code>Sketch</code> - Pencil sketch simulation<br>
        <code>Heat Map</code> - Thermal camera simulation<br>
        <code>Pixelate</code> - Retro pixel effect
    </div>

    <!-- Hidden canvas for video frame capture -->
    <canvas id="canvasInput" class="hidden"></canvas>

    <!-- Load OpenCV.js -->
    <script src="../../dist/opencv.js"></script>

    <script>
        // DOM Elements
        const statusEl = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const filterSelect = document.getElementById('filterSelect');
        const fpsEl = document.getElementById('fps');
        const video = document.getElementById('video');
        const canvasInput = document.getElementById('canvasInput');
        const canvasOutput = document.getElementById('canvasOutput');

        let isRunning = false;
        let animationId = null;
        let stream = null;
        let lastTime = performance.now();
        let frameCount = 0;

        // Wait for OpenCV to load
        cv.onRuntimeInitialized = () => {
            statusEl.textContent = 'OpenCV.js is ready! Click "Start Webcam" to begin.';
            statusEl.className = 'success';
            startBtn.disabled = false;
            console.log('OpenCV.js loaded');
        };

        // Start webcam
        startBtn.addEventListener('click', async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                video.srcObject = stream;

                video.onloadedmetadata = () => {
                    canvasInput.width = video.videoWidth;
                    canvasInput.height = video.videoHeight;
                    canvasOutput.width = video.videoWidth;
                    canvasOutput.height = video.videoHeight;

                    isRunning = true;
                    startBtn.classList.add('hidden');
                    stopBtn.classList.remove('hidden');
                    statusEl.textContent = 'Webcam active. Select a filter to apply.';
                    statusEl.className = 'success';

                    processFrame();
                };
            } catch (err) {
                statusEl.textContent = 'Error accessing webcam: ' + err.message;
                statusEl.className = 'error';
                console.error(err);
            }
        });

        // Stop webcam
        stopBtn.addEventListener('click', () => {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            video.srcObject = null;

            startBtn.classList.remove('hidden');
            stopBtn.classList.add('hidden');
            statusEl.textContent = 'Webcam stopped. Click "Start Webcam" to restart.';
            statusEl.className = '';
            fpsEl.textContent = 'FPS: --';
        });

        // Process video frames
        function processFrame() {
            if (!isRunning) return;

            const ctx = canvasInput.getContext('2d');
            ctx.drawImage(video, 0, 0);

            try {
                const src = cv.imread(canvasInput);
                const dst = new cv.Mat();
                const filter = filterSelect.value;

                switch (filter) {
                    case 'grayscale':
                        cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
                        break;

                    case 'canny':
                        const gray = new cv.Mat();
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                        cv.Canny(gray, dst, 50, 150);
                        gray.delete();
                        break;

                    case 'blur':
                        cv.GaussianBlur(src, dst, new cv.Size(15, 15), 0);
                        break;

                    case 'threshold':
                        const grayThresh = new cv.Mat();
                        cv.cvtColor(src, grayThresh, cv.COLOR_RGBA2GRAY);
                        cv.adaptiveThreshold(grayThresh, dst, 255,
                            cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
                        grayThresh.delete();
                        break;

                    case 'invert':
                        cv.bitwise_not(src, dst);
                        break;

                    case 'cartoon':
                        // Bilateral filter for smoothing while keeping edges
                        const color = new cv.Mat();
                        cv.cvtColor(src, color, cv.COLOR_RGBA2RGB);
                        const bilateral = new cv.Mat();
                        cv.bilateralFilter(color, bilateral, 9, 75, 75);

                        // Get edges
                        const grayCart = new cv.Mat();
                        cv.cvtColor(color, grayCart, cv.COLOR_RGB2GRAY);
                        const blurCart = new cv.Mat();
                        cv.medianBlur(grayCart, blurCart, 7);
                        const edges = new cv.Mat();
                        cv.adaptiveThreshold(blurCart, edges, 255,
                            cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 9, 2);

                        // Combine
                        const edgesColor = new cv.Mat();
                        cv.cvtColor(edges, edgesColor, cv.COLOR_GRAY2RGB);
                        cv.bitwise_and(bilateral, edgesColor, dst);
                        cv.cvtColor(dst, dst, cv.COLOR_RGB2RGBA);

                        color.delete(); bilateral.delete(); grayCart.delete();
                        blurCart.delete(); edges.delete(); edgesColor.delete();
                        break;

                    case 'sketch':
                        const graySketch = new cv.Mat();
                        cv.cvtColor(src, graySketch, cv.COLOR_RGBA2GRAY);
                        const blurSketch = new cv.Mat();
                        cv.GaussianBlur(graySketch, blurSketch, new cv.Size(21, 21), 0);
                        cv.divide(graySketch, blurSketch, dst, 256);
                        graySketch.delete();
                        blurSketch.delete();
                        break;

                    case 'heatmap':
                        const grayHeat = new cv.Mat();
                        cv.cvtColor(src, grayHeat, cv.COLOR_RGBA2GRAY);
                        cv.applyColorMap(grayHeat, dst, cv.COLORMAP_JET);
                        cv.cvtColor(dst, dst, cv.COLOR_BGR2RGBA);
                        grayHeat.delete();
                        break;

                    case 'pixelate':
                        const pixelSize = 10;
                        const small = new cv.Mat();
                        const newWidth = Math.floor(src.cols / pixelSize);
                        const newHeight = Math.floor(src.rows / pixelSize);
                        cv.resize(src, small, new cv.Size(newWidth, newHeight), 0, 0, cv.INTER_LINEAR);
                        cv.resize(small, dst, new cv.Size(src.cols, src.rows), 0, 0, cv.INTER_NEAREST);
                        small.delete();
                        break;

                    default:
                        src.copyTo(dst);
                }

                cv.imshow(canvasOutput, dst);
                src.delete();
                dst.delete();

                // Calculate FPS
                frameCount++;
                const now = performance.now();
                if (now - lastTime >= 1000) {
                    fpsEl.textContent = `FPS: ${frameCount}`;
                    frameCount = 0;
                    lastTime = now;
                }

            } catch (err) {
                console.error('Processing error:', err);
            }

            animationId = requestAnimationFrame(processFrame);
        }
    </script>
</body>
</html>
